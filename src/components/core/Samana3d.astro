<canvas id="webgl-canvas" class="fixed top-0 left-0 w-full h-full z-10 pointer-events-none will-change-transform"></canvas>

<script>
    // 1. Importaciones dinámicas para reducir el bundle inicial
    import gsap from 'gsap';
    import { ScrollTrigger } from 'gsap/ScrollTrigger';

    async function initWebGL() {
        // Carga de Three.js bajo demanda
        const THREE = await import('three');
        gsap.registerPlugin(ScrollTrigger);

        const canvas = document.querySelector('#webgl-canvas') as HTMLCanvasElement;
        if (!canvas) return;

        // 2. Configuración de Escena con Low-Power mode
        const escena = new THREE.Scene();
        const camara = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camara.position.z = 5;

        const render = new THREE.WebGLRenderer({
            canvas,
            alpha: true,
            antialias: window.devicePixelRatio < 2, // Antialias solo en pantallas de baja densidad
            powerPreference: "high-performance"
        });
        
        render.setSize(window.innerWidth, window.innerHeight);
        render.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // 3. Geometría y Material (Color Samana Gold)
        const geometrico = new THREE.IcosahedronGeometry(2, 0);
        const material = new THREE.MeshPhysicalMaterial({
            color: 0xffd400,
            roughness: 0.2,
            metalness: 1.0,
            flatShading: true,
        });
        const mesh = new THREE.Mesh(geometrico, material);
        escena.add(mesh);

        escena.add(new THREE.AmbientLight(0xffffff, 1));
        const luzDir = new THREE.DirectionalLight(0xffffff, 3);
        luzDir.position.set(5, 5, 5);
        escena.add(luzDir);

        // 4. Animación controlada (Ticker de GSAP para sincronía total)
        const animate = () => {
            mesh.rotation.x += 0.002;
            mesh.rotation.y += 0.002;
            render.render(escena, camara);
        };
        
        gsap.ticker.add(animate);

        // 5. Coreografía de Scroll con optimización de memoria
        const tl = gsap.timeline({
            scrollTrigger: {
                trigger: 'main',
                start: 'top top',
                end: 'bottom bottom',
                scrub: 1,
                invalidateOnRefresh: true,
            },
        });

        tl.to(mesh.position, { x: -4, y: 1, z: -2, ease: "power1.inOut" })
          .to(mesh.rotation, { x: Math.PI * 2, y: Math.PI, ease: "none" }, '<')
          .to(mesh.position, { x: 3, y: -1, z: 0, ease: "power1.inOut" })
          .to(mesh.scale, { x: 0.5, y: 0.5, z: 0.5, ease: "power1.inOut" }, '<');

        // 6. Resize optimizado con Debounce
        window.addEventListener('resize', () => {
            camara.aspect = window.innerWidth / window.innerHeight;
            camara.updateProjectionMatrix();
            render.setSize(window.innerWidth, window.innerHeight);
        }, { passive: true });

        // Limpieza para evitar memory leaks en Astro
        document.addEventListener('astro:before-swap', () => {
            gsap.ticker.remove(animate);
            render.dispose();
            geometrico.dispose();
            material.dispose();
        }, { once: true });
    }

    // Ejecución solo cuando el navegador está inactivo para no bloquear el LCP
    if ('requestIdleCallback' in window) {
        window.requestIdleCallback(() => setTimeout(initWebGL, 200));
    } else {
        document.addEventListener('astro:page-load', () => setTimeout(initWebGL, 300));
    }
</script>